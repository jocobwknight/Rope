# Rope
A time traveler's programming language

(THIS PROJECT HAS ONLY JUST BEGUN – THIS IS MORE OF A MANIFESTO THAN A README RIGHT NOW)

Rope is an possible answer to a what-if question:
"What if we could take everything we know about programming languages back to the beginning and do it all over again?"

A conventional answer is take the best of what we have and send it back. But that solution would do nothing more than move us further down the same path. That path, to be blunt, is a chain of dissatisfaction. Each new generation claims to cure the flaws of the last generation. Perfection will ever be achieved that way, because perfection does not arise from entropy.

Pessimism isn't for everyone, but Rope embraces it! Rope answers the question differently:
“Perfection is impossible, so let's aim for procrastination instead!”

Instead of a language that tries to do anything itself, or even tries to be perfect, Rope is designed to make it easier for the next generation. You could think of it as a language to define languages. For this, it offers four basic functions:

## Recall
The ability to use information that already exists

## Observe
The ability to capture information as it comes into existence

## Prove
The ability to bring new information into existence

## Express
The ability to declare the existence of information

With these four functions, it's possible to markup how a new language will handle the past, present, and future information, as well as use it to take action. Whatever is defined by Rope, can be run by it. And because any syntax or paradigm can be defined with Rope, it will also be possible to build a definition to ingest preexisting languages and run them as well. In this way, Rope can "tie together" all languages, and facilitate any new language that comes to be.

And because Rope is as basic as possible, it is rewritable all the way to the roots, allowing for the community to revise the efficiency of algorithms that serve as the backend for common functions used in higher level languages. Meaning that, over time all languages that use Rope as the backend interpreter or compiler will be more performant than their originals.

Finally, Rope can also define algorithmic standards, which, if set up properly, can allow for bidirectional translation to and from higher level languages. If set up, it can serve as a translator from one language to another.

This, in its own way, answers the original question. Assuming perfection is impossible, and change is constant, then the answer is to make “change” itself as easy as possible.

## Nomenclature
Rope has four main feature categories, and in each of those four there are four sub-features. In each of those four sub-features, there are four (sub-)sub-features. As more needs arise, more nested layers can be added. This fractal pattern will help with organization and discussion, as well as become a central part of the language parsing. While this is just the beginning stage and these are subject to change, I have written out the first three layers:
* Recall
  * Actual
    * Literals
    * Objects
    * Variables
    * Enclosures
  * Referential
    * Actualizations
    * Code
    * Imports
    * Designs
  * Mutative
    * Actualizations
    * References
    * Operations
    * Utilities
  * Immaterial
    * Actualizations
    * References
    * Mutations
    * Selves
* Observe
  * Recallable
    * Actualizations
    * References
    * Mutations
    * Immaterials
  * Exterior
    * Recalls
    * Equipment
    * Systems
    * Telemetries
  * Comparative
    * Recalls
    * Exteriors
    * Booleans
    * Iterations
  * Active
    * Recalls
    * Exteriors
    * Comparisons
    * Threads
* Prove
  * Recallable
    * Actualizations
    * References
    * Mutations
    * Immaterials
  * Observable
    * Recalls
    * Exteriors
    * Comparisons
    * Activities
  * Mathematical
    * Recalls
    * Observations
    * Calculations
    * Algorithms
  * Exceptional
    * Recalls
    * Observations
    * Mathematics
    * Errors
* Express
  * Recallable
    * Actualizations
    * References
    * Mutations
    * Immaterials
  * Observable
    * Recollections
    * Exteriors
    * Comparisons
    * Activities
  * Provable
    * Recalls
    * Observations
    * Mathematics
    * Exceptions
  * Elementary
    * Recalls
    * Observations
    * Proofs
    * Extensions

Notice there is another convention integrated into the nomenclature. Lower categories initially reference aforementioned categories. This means that Express inherits everything from Recall, Observe, and Prove. This will help with memorizing, but it will mean that initial planning is going to be vital to achieve computational universality. In practice, it will also mean that Express will probably get the most use in code, while Recall will get the most review and revision on the backend.
